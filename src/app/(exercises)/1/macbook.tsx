/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useRef, useState } from 'react'

import * as THREE from 'three'

import { Html, useGLTF, useTexture } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'

import { animated, useSpring } from '@react-spring/three'
import { twMerge } from 'tailwind-merge'

import type { GLTF } from 'three-stdlib'

const bodyMaterial = new THREE.MeshStandardMaterial({
  color: '#3A3A3C',
  metalness: 0.9,
  roughness: 0.4,
})

interface GLTFResult extends GLTF {
  materials: unknown
  nodes: {
    body: THREE.Mesh
    ['display-body']: THREE.Mesh
    ['display-screen']: THREE.Mesh
    keyboard: THREE.Mesh
    racks: THREE.Mesh
  }
}

type MacBookProps = JSX.IntrinsicElements['group'] & {
  open: boolean
}

export function MacBook(props: MacBookProps) {
  const { open, position, ...restProps } = props
  const { nodes } = useGLTF('/1/mba.glb') as GLTFResult
  const [logoTexture] = useTexture(['/1/apple.png'])

  const groupRef = useRef<THREE.Group>(null)
  const [showScreen, setShowScreen] = useState(false)

  useFrame((state) => {
    if (!groupRef.current) return
    const t = state.clock.getElapsedTime()
    groupRef.current.rotation.x = THREE.MathUtils.lerp(
      groupRef.current.rotation.x,
      open ? Math.cos(t / 10) / 10 + 0.25 : 0,
      0.1,
    )
    groupRef.current.rotation.y = THREE.MathUtils.lerp(
      groupRef.current.rotation.y,
      open ? Math.sin(t / 10) / 4 : 0,
      0.1,
    )
    groupRef.current.rotation.z = THREE.MathUtils.lerp(
      groupRef.current.rotation.z,
      open ? Math.sin(t / 10) / 10 : 0,
      0.1,
    )

    const currentY = (position as number[] | undefined)?.[1] ?? 0
    groupRef.current.position.y = THREE.MathUtils.lerp(
      groupRef.current.position.y,
      open ? (-1.5 + Math.sin(t)) / 50 : currentY,
      0.1,
    )
  })

  const springs = useSpring({
    rotationX: open ? -1.745 : 0,
    onChange(result) {
      setShowScreen(result.value.rotationX < -1.5)
    },
  })

  return (
    <group {...restProps} ref={groupRef} dispose={null} position={position}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.body.geometry}
        material={bodyMaterial}
      />
      <animated.group
        position={[0, 0.0061, -0.105]}
        rotation-x={springs.rotationX}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes['display-body'].geometry}
          material={bodyMaterial}
          position={[0, -0.034, 0.105]}
        />
        <mesh position={[0, 0.007, 0.12]} rotation={[Math.PI / 2, Math.PI, 0]}>
          <planeGeometry args={[0.05, 0.05]} />
          <meshStandardMaterial
            transparent
            map={logoTexture}
            metalness={1}
            roughness={0}
          />
        </mesh>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes['display-screen'].geometry}
          position={[0, -0.034, 0.105]}
        >
          <meshStandardMaterial
            color='#000000'
            metalness={0.1}
            roughness={0.1}
          />
          <Html
            occlude
            transform
            distanceFactor={0.072}
            position={[0, 0.035, 0.005]}
            rotation-x={Math.PI / 2}
          >
            <iframe
              className={twMerge(
                'aspect-[3/2] w-[1600px] select-none rounded-t-[30px] bg-black transition-opacity opacity-0',
                showScreen && 'opacity-100',
                !open && 'opacity-0',
              )}
              src='https://zhangyu.dev'
              style={{
                clipPath:
                  'polygon(0 0,45% 0,45% 20px,calc(45% + 1px) 21px,calc(45% + 2px) 22px,calc(45% + 3px) 23px,calc(45% + 4px) 24px,calc(45% + 5px) 25px,calc(55% - 5px) 25px,calc(55% - 4px) 24px,calc(55% - 3px) 23px,calc(55% - 2px) 22px,calc(55% - 1px) 21px,55% 20px,55% 0,100% 0,100% 100%,0 100%)',
              }}
              title='zhangyu.dev'
            />
          </Html>
        </mesh>
      </animated.group>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.keyboard.geometry}
        position={[0, 0.0012, 0]}
      >
        <meshStandardMaterial color='#333333' metalness={0.2} roughness={0.5} />
      </mesh>
      <mesh castShadow receiveShadow geometry={nodes.racks.geometry}>
        <meshBasicMaterial color='#333333' />
      </mesh>
    </group>
  )
}

useGLTF.preload('/1/mba.glb')
